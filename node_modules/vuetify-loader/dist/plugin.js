"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VuetifyLoaderPlugin = void 0;
const path = __importStar(require("upath"));
const url_1 = require("url");
const loader_shared_1 = require("@vuetify/loader-shared");
// Can't use require.resolve() for this, it doesn't work with resolve.symlinks
let vuetifyBase;
async function getVuetifyBase(base, context, resolver) {
    if (!getVuetifyBase.promise) {
        let resolve;
        getVuetifyBase.promise = new Promise((_resolve) => resolve = _resolve);
        resolver.resolve({}, base, 'vuetify/package.json', context, (err, vuetifyPath) => {
            if (vuetifyPath) {
                vuetifyBase = path.dirname(vuetifyPath);
            }
            resolve(true);
        });
    }
    return getVuetifyBase.promise;
}
getVuetifyBase.promise = null;
class VuetifyLoaderPlugin {
    constructor(options) {
        this.options = {
            autoImport: true,
            styles: true,
            ...options,
        };
    }
    apply(compiler) {
        if (this.options.autoImport) {
            compiler.options.module.rules.unshift({
                resourceQuery: query => {
                    if (!query)
                        return false;
                    const qs = new url_1.URLSearchParams(query);
                    return qs.has('vue') && (qs.get('type') === 'template' ||
                        (qs.get('type') === 'script' && qs.has('setup')));
                },
                use: { loader: require.resolve('./scriptLoader') },
            });
        }
        if (this.options.styles === 'none' ||
            this.options.styles === 'expose') {
            compiler.options.module.rules.push({
                enforce: 'pre',
                test: /\.css$/,
                include: /node_modules[/\\]vuetify[/\\]/,
                issuer: /node_modules[/\\]vuetify[/\\]/,
                loader: 'null-loader',
            });
        }
        if (this.options.styles === 'expose') {
            function isSubdir(root, test) {
                const relative = path.relative(root, test);
                return relative && !relative.startsWith('..') && !path.isAbsolute(relative);
            }
            const files = new Set();
            let resolve;
            let promise;
            let timeout;
            async function awaitResolve() {
                clearTimeout(timeout);
                timeout = setTimeout(() => {
                    resolve(true);
                }, 500);
                if (!promise) {
                    promise = new Promise((_resolve) => resolve = _resolve);
                    let start = files.size;
                    await promise;
                    if (files.size > start) {
                        await (0, loader_shared_1.writeStyles)(files);
                    }
                    promise = null;
                }
                return promise;
            }
            compiler.options.module.rules.push({
                enforce: 'pre',
                test: /\.s[ac]ss$/,
                loader: require.resolve('./styleLoader'),
                options: { awaitResolve },
            });
            compiler.options.resolve.plugins = compiler.options.resolve.plugins || [];
            compiler.options.resolve.plugins.push({
                apply(resolver) {
                    resolver
                        .getHook('resolve')
                        .tapAsync('vuetify-loader', async (request, context, callback) => {
                        var _a;
                        if (request.path && !vuetifyBase && request.request !== 'vuetify/package.json') {
                            await getVuetifyBase(request.path, context, resolver);
                        }
                        if (!(request.path &&
                            ((_a = request.request) === null || _a === void 0 ? void 0 : _a.endsWith('.css')) &&
                            isSubdir(vuetifyBase, request.path))) {
                            return callback();
                        }
                        resolver.resolve({}, request.path, request.request.replace(/\.css$/, '.sass'), context, (err, resolution) => {
                            if (resolution && !files.has(resolution)) {
                                awaitResolve();
                                files.add(resolution);
                            }
                            return callback();
                        });
                    });
                }
            });
        }
    }
}
exports.VuetifyLoaderPlugin = VuetifyLoaderPlugin;
//# sourceMappingURL=plugin.js.map